#!/usr/bin/python3
"""main file to see execution"""

from io import StringIO
from re import L
from typing import List
import os
from pyjsonedit.tokenizer import tokenize, detokenize
from pyjsonedit.tree import parse as tree_parse
from pyjsonedit.tree import JsonNode
from pyjsonedit.matcher import match, match_as_string
from pyjsonedit.editor import Modifications, write_with_modifications

def __get_tokens(json) -> List:
    tokens=[]
    if os.path.isfile(json):
        with open(json) as handle:
            tokens = list(tokenize(handle))
    else:
        with StringIO(json) as handle:
            tokens = list(tokenize(handle))
    return tokens

def string_to_tokens(json_str: str) -> List:
    """
    python3 -c 'from main import *; print( string_to_tokens("{}") );'
    """
    return __get_tokens(json_str)

def string_to_tree(json_str: str) -> JsonNode:
    """
    python3 -c 'from main import *; r=string_to_tree("{}"); print(r)'
    """
    tokens = __get_tokens(json_str)
    return tree_parse(tokens)

def string_match_mark(json, pattern, symbol='X', color=None):
    """mark part of matched json"""
    tokens = __get_tokens(json)
    node = tree_parse(tokens)
    return match_as_string(json, node, pattern, symbol, color)

def cli_match_mark(pattern, json, symbol, color, callback=print):
    """cli method for masking matching parts of json"""

    tokens = []
    if os.path.isfile(json):
        with open(json) as handle:
            json = handle.read()

    with StringIO(json) as handle:
        tokens = list(tokenize(handle))

        node = tree_parse(tokens)
        ret = match_as_string(json, node, pattern, symbol, color)
        callback(ret)

def _run_on_each_match(pattern, json_input, callback=print):
    """run "callback" on each matching node"""

    is_file = os.path.isfile(json_input)
    json=""
    if is_file:
        with open(json) as handle:
            json = handle.read()
    else:
        json = json_input

    tokens = []
    with StringIO(json) as handle:
        tokens = list(tokenize(handle))
        node = tree_parse(tokens)
        for i in match(node, pattern):
            if isinstance(i, JsonNode):
                i = callback(i)
    return node



# def f2():
#     json_str = """{
#          'a': 10,

#           'b'  :   [1,  2,3], 'c':{} }"""

#     tokens = [ t for t in tokenize(StringIO(json_str)) ]

#     json_out = detokenize(json_str, tokens)


#     print(json_str)
#     print(tokens)
#     print(json_out)
#     assert json_str == json_out



# def decode_node(self):
#     ret = ""
#     if self.type == 'value':
#         ret += str(self.kids[0])
#     else:
#         if   self.type=='array': ret += '['
#         elif self.type=='dict':  ret += '{'
#         else:
#             raise ValueError( self.type )

#         for i,k in enumerate(self.kids):
#             ret += f'"{k.name}":'
#             ret += decode_node(k)
#             if i+1 < len(self.kids):
#                 ret+=','

#         if   self.type=='array': ret += ']'
#         elif self.type=='dict':  ret += '}'

#     return ret

# def tree2list(node:JsonNode, ret:list):
#     """flaten all tree nodes"""
#     if not isinstance(node, JsonNode):
#         return
#     ret.append(node)
#     for n in node.kids:
#         tree2list(n, ret)

# def print_json_tree_table(json_str:str):
#     """
#     prints huge table
#     usefull for debuging tree nodes
#     """
#     tree = string_to_tree(json_str)

#     width=2
#     line1 = [ f'{i:<{width}}'.format(i) for i in range(len(json_str))]
#     line2 = [ f'{c:<{width}}' for c in json_str]
#     print(*line1,sep='|')
#     print(*line2,sep='|')

#     tree_list=[]
#     tree2list(tree, tree_list)

#     for tl in tree_list:
#         print( '|'.join( '{:<2}'.format( 'X' if tl.end>i>=tl.start  else ' ') for i in range(len(json_str)) ) ,end='' )
#         print( f'JsonNode::{tl.type}[{tl.start}:{tl.end}]k={len(tl.kids)}')


def string_modify(pattern:str, json_str:str, calback_on_match, output_writer):
    modifications = Modifications()

    def match_action(node):
        mod = calback_on_match(node)
        if mod:
            modifications.add(node.start,node.end, mod)

    _run_on_each_match(pattern, json_str, match_action)
    
    write_with_modifications(json_str, modifications, output_writer.write)

# def f():
#     json_str = "{ 'a': 10, 'b': [1,  2,3], 'c':{} }"
#     pattern = "*"

#     print_json_tree_table(json_str)

#     ##
#     json_marked = []
#     cli_match_mark(pattern,json_str,'M',False, json_marked.append)
#     print(*[i.ljust(2) for i in json_marked[0]],sep='|',end='')
#     print("pattern match")
#     ##

#     modifications = Modifications()

#     def match_action(node):
#         raw = "duppppaduppppaduppppaduppppa"
#         modifications.add(node.start,node.end, raw)

#     run_on_each_match(pattern, json_str, match_action)

#     a = []
#     print_with_modifications(json_str, modifications, a.append)
#     print(' '.join(a))


def f():
    json_str = "{ 'a': 10, 'b': [1,  2,3], 'c':{} }"
    pattern = "b > *"

    def action(_):
        return  "'dupa'"

    out = StringIO()
    modify(pattern, json_str, action, out)
    out.seek(0)
    print(out.read())