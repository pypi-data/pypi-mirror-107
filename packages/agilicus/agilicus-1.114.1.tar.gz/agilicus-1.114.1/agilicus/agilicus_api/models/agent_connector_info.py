# coding: utf-8

"""
    Agilicus API

    Agilicus is API-first. Modern software is controlled by other software, is open, is available for you to use the way you want, securely, simply.  A rendered, online viewable and usable version of this specification is available at [api](https://www.agilicus.com/api). You may try the API inline directly in the web page. To do so, first obtain an Authentication Token (the simplest way is to install the Python SDK, and then run `agilicus-cli --issuer https://MYISSUER get-token`). You will need an org-id for most calls (and can obtain from `agilicus-cli --issuer https://MYISSUER list-orgs`). The `MYISSUER` will typically be `auth.MYDOMAIN`, and you will see it as you sign-in to the administrative UI.  This API releases on Bearer-Token authentication. To obtain a valid bearer token you will need to Authenticate to an Issuer with OpenID Connect (a superset of OAUTH2).  Your \"issuer\" will look like https://auth.MYDOMAIN. For example, when you signed-up, if you said \"use my own domain name\" and assigned a CNAME of cloud.example.com, then your issuer would be https://auth.cloud.example.com.  If you selected \"use an Agilicus supplied domain name\", your issuer would look like https://auth.myorg.agilicus.cloud.  For test purposes you can use our [Python SDK](https://pypi.org/project/agilicus/) and run `agilicus-cli --issuer https://auth.MYDOMAIN get-token`.  This API may be used in any language runtime that supports OpenAPI 3.0, or, you may use our [Python SDK](https://pypi.org/project/agilicus/), our [Typescript SDK](https://www.npmjs.com/package/@agilicus/angular), or our [Golang SDK](https://git.agilicus.com/pub/sdk-go).  100% of the activities in our system our API-driven, from our web-admin, through our progressive web applications, to all internals: there is nothing that is not accessible.  For more information, see [developer resources](https://www.agilicus.com/developer).   # noqa: E501

    The version of the OpenAPI document: 2021.05.26
    Contact: dev@agilicus.com
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from agilicus_api.configuration import Configuration


class AgentConnectorInfo(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'local_authentication_enabled': 'bool',
        'connections_info': 'list[AgentConnectorConnectionInfo]',
        'allow_list': 'AllowMapCompiled',
        'authz_public_key': 'str',
        'application_service_uri': 'str',
        'tunnel_uri': 'str',
        'service_forwarders': 'list[ServiceForwarder]',
        'from_service_forwarders': 'list[ServiceForwarder]'
    }

    attribute_map = {
        'local_authentication_enabled': 'local_authentication_enabled',
        'connections_info': 'connections_info',
        'allow_list': 'allow_list',
        'authz_public_key': 'authz_public_key',
        'application_service_uri': 'application_service_uri',
        'tunnel_uri': 'tunnel_uri',
        'service_forwarders': 'service_forwarders',
        'from_service_forwarders': 'from_service_forwarders'
    }

    def __init__(self, local_authentication_enabled=None, connections_info=None, allow_list=None, authz_public_key=None, application_service_uri=None, tunnel_uri=None, service_forwarders=None, from_service_forwarders=None, local_vars_configuration=None):  # noqa: E501
        """AgentConnectorInfo - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._local_authentication_enabled = None
        self._connections_info = None
        self._allow_list = None
        self._authz_public_key = None
        self._application_service_uri = None
        self._tunnel_uri = None
        self._service_forwarders = None
        self._from_service_forwarders = None
        self.discriminator = None

        if local_authentication_enabled is not None:
            self.local_authentication_enabled = local_authentication_enabled
        if connections_info is not None:
            self.connections_info = connections_info
        if allow_list is not None:
            self.allow_list = allow_list
        if authz_public_key is not None:
            self.authz_public_key = authz_public_key
        if application_service_uri is not None:
            self.application_service_uri = application_service_uri
        if tunnel_uri is not None:
            self.tunnel_uri = tunnel_uri
        if service_forwarders is not None:
            self.service_forwarders = service_forwarders
        if from_service_forwarders is not None:
            self.from_service_forwarders = from_service_forwarders

    @property
    def local_authentication_enabled(self):
        """Gets the local_authentication_enabled of this AgentConnectorInfo.  # noqa: E501

        Determines whether or not the agent will expose an endpoint for local authentication  # noqa: E501

        :return: The local_authentication_enabled of this AgentConnectorInfo.  # noqa: E501
        :rtype: bool
        """
        return self._local_authentication_enabled

    @local_authentication_enabled.setter
    def local_authentication_enabled(self, local_authentication_enabled):
        """Sets the local_authentication_enabled of this AgentConnectorInfo.

        Determines whether or not the agent will expose an endpoint for local authentication  # noqa: E501

        :param local_authentication_enabled: The local_authentication_enabled of this AgentConnectorInfo.  # noqa: E501
        :type: bool
        """

        self._local_authentication_enabled = local_authentication_enabled

    @property
    def connections_info(self):
        """Gets the connections_info of this AgentConnectorInfo.  # noqa: E501

        The list of connections associated with this agent  # noqa: E501

        :return: The connections_info of this AgentConnectorInfo.  # noqa: E501
        :rtype: list[AgentConnectorConnectionInfo]
        """
        return self._connections_info

    @connections_info.setter
    def connections_info(self, connections_info):
        """Sets the connections_info of this AgentConnectorInfo.

        The list of connections associated with this agent  # noqa: E501

        :param connections_info: The connections_info of this AgentConnectorInfo.  # noqa: E501
        :type: list[AgentConnectorConnectionInfo]
        """

        self._connections_info = connections_info

    @property
    def allow_list(self):
        """Gets the allow_list of this AgentConnectorInfo.  # noqa: E501


        :return: The allow_list of this AgentConnectorInfo.  # noqa: E501
        :rtype: AllowMapCompiled
        """
        return self._allow_list

    @allow_list.setter
    def allow_list(self, allow_list):
        """Sets the allow_list of this AgentConnectorInfo.


        :param allow_list: The allow_list of this AgentConnectorInfo.  # noqa: E501
        :type: AllowMapCompiled
        """

        self._allow_list = allow_list

    @property
    def authz_public_key(self):
        """Gets the authz_public_key of this AgentConnectorInfo.  # noqa: E501

        The PEM encoded public key used for validating bearer tokens  # noqa: E501

        :return: The authz_public_key of this AgentConnectorInfo.  # noqa: E501
        :rtype: str
        """
        return self._authz_public_key

    @authz_public_key.setter
    def authz_public_key(self, authz_public_key):
        """Sets the authz_public_key of this AgentConnectorInfo.

        The PEM encoded public key used for validating bearer tokens  # noqa: E501

        :param authz_public_key: The authz_public_key of this AgentConnectorInfo.  # noqa: E501
        :type: str
        """

        self._authz_public_key = authz_public_key

    @property
    def application_service_uri(self):
        """Gets the application_service_uri of this AgentConnectorInfo.  # noqa: E501

        The URI this connector will establish as the destination URI for service forwarder requests. An agent would request a certificate for the hostname provided as part of the URI for other connectors to establish a TLS connection to this connector.   # noqa: E501

        :return: The application_service_uri of this AgentConnectorInfo.  # noqa: E501
        :rtype: str
        """
        return self._application_service_uri

    @application_service_uri.setter
    def application_service_uri(self, application_service_uri):
        """Sets the application_service_uri of this AgentConnectorInfo.

        The URI this connector will establish as the destination URI for service forwarder requests. An agent would request a certificate for the hostname provided as part of the URI for other connectors to establish a TLS connection to this connector.   # noqa: E501

        :param application_service_uri: The application_service_uri of this AgentConnectorInfo.  # noqa: E501
        :type: str
        """

        self._application_service_uri = application_service_uri

    @property
    def tunnel_uri(self):
        """Gets the tunnel_uri of this AgentConnectorInfo.  # noqa: E501

        The URI this connector uses to establish its tunnels.  # noqa: E501

        :return: The tunnel_uri of this AgentConnectorInfo.  # noqa: E501
        :rtype: str
        """
        return self._tunnel_uri

    @tunnel_uri.setter
    def tunnel_uri(self, tunnel_uri):
        """Sets the tunnel_uri of this AgentConnectorInfo.

        The URI this connector uses to establish its tunnels.  # noqa: E501

        :param tunnel_uri: The tunnel_uri of this AgentConnectorInfo.  # noqa: E501
        :type: str
        """

        self._tunnel_uri = tunnel_uri

    @property
    def service_forwarders(self):
        """Gets the service_forwarders of this AgentConnectorInfo.  # noqa: E501

        The list of service forwarders associated with this connector.  # noqa: E501

        :return: The service_forwarders of this AgentConnectorInfo.  # noqa: E501
        :rtype: list[ServiceForwarder]
        """
        return self._service_forwarders

    @service_forwarders.setter
    def service_forwarders(self, service_forwarders):
        """Sets the service_forwarders of this AgentConnectorInfo.

        The list of service forwarders associated with this connector.  # noqa: E501

        :param service_forwarders: The service_forwarders of this AgentConnectorInfo.  # noqa: E501
        :type: list[ServiceForwarder]
        """

        self._service_forwarders = service_forwarders

    @property
    def from_service_forwarders(self):
        """Gets the from_service_forwarders of this AgentConnectorInfo.  # noqa: E501

        The list of service forwarders that are forwarded to this connector.  # noqa: E501

        :return: The from_service_forwarders of this AgentConnectorInfo.  # noqa: E501
        :rtype: list[ServiceForwarder]
        """
        return self._from_service_forwarders

    @from_service_forwarders.setter
    def from_service_forwarders(self, from_service_forwarders):
        """Sets the from_service_forwarders of this AgentConnectorInfo.

        The list of service forwarders that are forwarded to this connector.  # noqa: E501

        :param from_service_forwarders: The from_service_forwarders of this AgentConnectorInfo.  # noqa: E501
        :type: list[ServiceForwarder]
        """

        self._from_service_forwarders = from_service_forwarders

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, AgentConnectorInfo):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, AgentConnectorInfo):
            return True

        return self.to_dict() != other.to_dict()
